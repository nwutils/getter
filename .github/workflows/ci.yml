name: ci

on:
  pull_request:
    branches:
      - main

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

jobs:
  tests:
    strategy:
      matrix:
        os:
          - macos-15
          - ubuntu-24.04
          - windows-2025
      fail-fast: false

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5.0.0

      - name: Setup Volta
        uses: volta-cli/action@v4.2.1

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        id: run_tests
        shell: bash
        run: |
          set -o pipefail
          node --experimental-test-coverage --test ./tests/specs/request.test.js 2>&1 | tee raw_test_output.txt

      - name: Clean ANSI colors
        shell: bash
        run: |
          sed -r "s/\x1B\[[0-9;]*[mK]//g" raw_test_output.txt > test_output.txt

            - name: Parse coverage section and convert to markdown table
        id: parse
        shell: bash
        run: |
          # Extract coverage block between markers (case-insensitive)
          awk '
            BEGIN { capture=0 }
            tolower($0) ~ /start of coverage report/ { capture=1; next }
            tolower($0) ~ /end of coverage report/ { capture=0 }
            capture == 1 { print }
          ' test_output.txt > coverage_raw.txt

          # If nothing was found, write a fallback message
          if [ ! -s coverage_raw.txt ]; then
            echo "âš ï¸ No coverage found" > coverage_md.txt
            echo "COVERAGE<<EOF" >> $GITHUB_OUTPUT
            cat coverage_md.txt >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Remove leading "i " markers, dashed divider lines, and trim
          sed 's/^i //' coverage_raw.txt | sed '/^[-[:space:]]*$/d' > coverage_clean.txt

          # Remove the repeated header row like: "file | line % | branch % | funcs % | uncovered lines"
          sed -i '/file[[:space:]]*|[[:space:]]*line %/I d' coverage_clean.txt || true

          # Keep only rows that look like real data: either contain a '%' (coverage numbers)
          # or the "all files" summary line
          grep -E '%' coverage_clean.txt > coverage_rows.txt || true
          grep -Ei '^all files' coverage_clean.txt >> coverage_rows.txt || true

          # If still empty, fallback
          if [ ! -s coverage_rows.txt ]; then
            echo "âš ï¸ Coverage block found but no parsable rows." > coverage_md.txt
            echo "COVERAGE<<EOF" >> $GITHUB_OUTPUT
            cat coverage_md.txt >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Build markdown table header
          {
            echo "| File | Line % | Branch % | Funcs % | Uncovered Lines |"
            echo "|------|--------|----------|---------|------------------|"

            # Normalize and output each data row as a markdown row
            while IFS= read -r line; do
              # trim
              line=$(echo "$line" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')

              # If the row uses '|' separators, parse using them
              if echo "$line" | grep -q '|'; then
                file=$(echo "$line" | cut -d'|' -f1 | xargs)
                linep=$(echo "$line" | cut -d'|' -f2 | xargs)
                branchp=$(echo "$line" | cut -d'|' -f3 | xargs)
                funcp=$(echo "$line" | cut -d'|' -f4 | xargs)
                miss=$(echo "$line" | cut -d'|' -f5- | xargs)
              else
                # Fallback: split by whitespace assuming last cols are numeric/percent and missing list
                # e.g. "request.js    72.00   57.14   42.86   20-23 31-34"
                # Extract last 3-4 tokens as percentages/missed
                # NF = number of fields
                # linep = NF-3, branchp = NF-2, funcp = NF-1, miss = last field(s) (if any)
                nf=$(echo "$line" | awk '{print NF}')
                if [ "$nf" -ge 4 ]; then
                  linep=$(echo "$line" | awk '{print $(NF-3)}')
                  branchp=$(echo "$line" | awk '{print $(NF-2)}')
                  funcp=$(echo "$line" | awk '{print $(NF-1)}')
                  miss=$(echo "$line" | awk '{for(i=NF;i>=NF;i--) printf $i; print ""}')
                  # file = everything except the last 3 fields
                  file=$(echo "$line" | awk '{for(i=1;i<=NF-3;i++) printf $i (i==NF-3?"" " "); print ""}' | xargs)
                else
                  # can't parse properly; treat whole line as file
                  file="$line"
                  linep=" "
                  branchp=" "
                  funcp=" "
                  miss=" "
                fi
              fi

              # Normalize file path indentation (replace multiple spaces with / where appropriate)
              file=$(echo "$file" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')

              # Print the markdown table row
              echo "| $file | $linep | $branchp | $funcp | $miss |"
            done < coverage_rows.txt

          } > coverage_md.txt

          # Expose the markdown through the workflow output
          echo "COVERAGE<<EOF" >> $GITHUB_OUTPUT
          cat coverage_md.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create or update PR comment for OS
        uses: peter-evans/create-or-update-comment@v3
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body-includes: "<!-- coverage-${{ matrix.os }} -->"
          edit-mode: replace
          body: |
            <!-- coverage-${{ matrix.os }} -->
            ## ðŸ§ª Test Coverage Report â€” **${{ matrix.os }}**
            ```
            ${{ steps.parse.outputs.COVERAGE }}
            ```
